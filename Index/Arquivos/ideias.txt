Mute: comando que permite silenciar um usuário no servidor, impedindo-o de enviar mensagens ou falar em canais de voz por um tempo determinado.
Tempmute: comando semelhante ao mute, porém com um tempo determinado para que o usuário seja desmutado automaticamente.
Warn: comando que permite dar um aviso a um usuário por comportamento inadequado.
Tempban: comando que permite banir um usuário por um tempo determinado.
Slowmode: comando que permite definir um tempo mínimo entre as mensagens enviadas em um canal.
Lockdown: comando que permite trancar um canal, impedindo que qualquer usuário envie mensagens nele.
Nuke: comando que permite apagar todas as mensagens de um canal e reiniciá-lo do zero.


remova o sistema de categorias desse ajuda.js, use o data: new SlashCommandBuilder() para selecionar o ajuda que será vista, exemplo:/ajuda pterodactyl, junto com os sistema que só vai mostrar as categorias existentes caso o usuario tenha a permissão necessaria para ver elas, caso a categoria não tenha restrição então deixar a mostra, config.json abaixo, e o ajuda.js está abaixo do config.json

config.json

  "categories": [
    {
      "name": "Master",
      "description": "Comandos de Administração Total",
      "color": "#ff0000",
      "requiredRole": "1002406068191756488",
      "main": true
    },
    {
      "name": "Administradores",
      "description": "Comandos de administração do servidor",
      "color": "#ff0000",
      "requiredRole": "1002406551748870174",
      "main": true
    },
    {
      "name": "Pterodactyl",
      "description": "Comandos da Pterodactyl-API",
      "color": "#00ff00",
      "main": true
    },
    {
      "name": "Membros",
      "description": "Comandos úteis para o servidor",
      "color": "#00ff00",
      "main": true
    },
    {
      "name": "Ainda Não Sei",
      "description": "Coisas que o Chat GPT me recomenda",
      "color": "YELLOW",
      "main": true
    }
  ]

ajuda.js

const { SlashCommandBuilder } = require('@discordjs/builders');
const { MessageActionRow, MessageSelectMenu, MessageButton, MessageEmbed } = require('discord.js');
const config = require('../../Config/config.json');

module.exports = {
  data: new SlashCommandBuilder()
    .setName('ajuda')
    .setDescription('Mostra a lista de comandos disponíveis'),
  async execute(interaction) {
    const commands = interaction.client.commands;
    const categories = config.categories;
    const interactionTimeout = 30000; // tempo limite de interação em milissegundos (30 segundos)

    // Create select menu options for each main category
    const selectMenuOptions = categories
      .filter(category => category.main && (!category.requiredRole || interaction.member.roles.cache.some(role => role.id === category.requiredRole)))
      .map(category => ({
        label: category.name,
        value: category.name,
        description: category.description
      }));

    // Create select menu row
    const selectMenuRow = new MessageActionRow()
      .addComponents(
        new MessageSelectMenu()
          .setCustomId('main_category_select')
          .setPlaceholder('Escolha uma categoria')
          .addOptions(selectMenuOptions)
      );

    if (selectMenuOptions.length === 0) {
      backButton.setDisabled(true);
    }

    // Create back button to show main categories again
    const backButton = new MessageButton()
      .setCustomId('back_button')
      .setLabel('Voltar')
      .setStyle('SECONDARY');

    // Create button row with only the back button
    const buttonRow = new MessageActionRow()
      .addComponents(backButton);

    try {
      // Send initial message with select menu and button row
      const initialMessage = await interaction.reply({ content: 'Escolha uma categoria:', components: [selectMenuRow, buttonRow] });
      if (selectMenuOptions.length === 0) {
        buttonRow.components[0].setDisabled(true);
      }
      // Inicia um timer para finalizar a interação após 30 segundos
      const interactionTimer = setTimeout(async () => {
        // Remove a mensagem e desabilita os componentes
        await initialMessage.edit({ content: 'Ajuda finalizada, para usar novamente digite /ajuda.', components: [] });
        // Para o coletor de eventos
        collector.stop();
      }, interactionTimeout);

      // Handle select menu and button interactions
      const filter = i => i.user.id === interaction.user.id;
      const collector = interaction.channel.createMessageComponentCollector({ filter, time: 15000 });

      collector.on('collect', async i => {
        if (i.customId === 'main_category_select') {
          // Handle main category select menu interaction
          const selectedCategory = categories.find(category => category.name === i.values[0]);

          // Create an embed for the selected category
          const embed = new MessageEmbed()
            .setColor(selectedCategory.color)
            .setTitle(selectedCategory.name)
            .setDescription(selectedCategory.description)
            .setThumbnail(config.Logo);


          // Add fields for each command in the selected category
          const commandsInCategory = commands.filter(command => command.category === selectedCategory.name);
          for (const command of commandsInCategory.values()) {
            embed.addField(`/${command.data.name}`, command.data.description || 'Sem descrição');
          }

          // Edit the initial message with the selected category's commands and button row
          await i.update({ content: 'Aqui estão os comandos da categoria selecionada:', embeds: [embed], components: [buttonRow] });
        } else if (i.customId === 'back_button') {
          // Handle back button interaction
          // Edit the message with the select menu and button row again
          await i.update({ content: 'Selecione a categoria:', components: [selectMenuRow, buttonRow] });
        }
      });

      collector.on('end', async () => {
        // Cancela o timer de finalização da interação
        clearTimeout(interactionTimer);
        // Remove the select menu and button row from the message
        await initialMessage.edit({ components: [] });
      });
    } catch (error) {
      console.error(error);
      // tratamento de erro, por exemplo, enviar uma mensagem para o usuário informando que ocorreu um erro
    }
  },
};    